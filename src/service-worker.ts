/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';

declare const self: ServiceWorkerGlobalScope;
declare const clients: Clients;

// Precache and route assets generated by Vite PWA plugin
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches from previous versions
cleanupOutdatedCaches();

// ============================================================================
// PUSH NOTIFICATION INFRASTRUCTURE (INACTIVE - MVP)
// ============================================================================
// This infrastructure is in place for future activation of push notifications.
// In the current MVP, no actual push notifications are sent from the backend.
// Handlers are tested and ready for activation in future releases.
// ============================================================================

/**
 * Push Event Listener (INACTIVE INFRASTRUCTURE)
 *
 * Handles incoming push notifications from the backend.
 * Currently inactive in MVP - infrastructure only.
 *
 * Expected payload structure:
 * {
 *   title: string,       // Notification title
 *   body: string,        // Notification message
 *   icon?: string,       // Icon URL (defaults to app icon)
 *   badge?: string,      // Badge icon URL (optional)
 *   data?: {            // Custom data for routing
 *     url: string,       // Target route when notification clicked
 *     type?: string,     // Notification type (e.g., 'ot_approved')
 *     ...               // Additional custom fields
 *   }
 * }
 */
self.addEventListener('push', (event: PushEvent) => {
  console.log('[SW] Push event received (infrastructure only, not active in MVP)');

  // Default notification data with fallback values
  let notificationData = {
    title: 'OTMS Notification',
    body: 'You have a new update',
    icon: '/icons/icon-512x512.png',
    badge: '/icons/icon-192x192.png', // Using 192x192 as badge since no dedicated badge icon
    data: { url: '/' }
  };

  try {
    // Parse incoming push payload
    if (event.data) {
      const payload = event.data.json();

      // Merge payload with defaults, preserving fallbacks for missing fields
      notificationData = {
        title: payload.title || notificationData.title,
        body: payload.body || notificationData.body,
        icon: payload.icon || notificationData.icon,
        badge: payload.badge || notificationData.badge,
        data: payload.data || notificationData.data
      };

      console.log('[SW] Push payload parsed:', {
        title: notificationData.title,
        hasData: !!notificationData.data
      });
    }
  } catch (error) {
    console.error('[SW] Error parsing push payload:', error);
    // Continue with fallback notification data
    console.log('[SW] Using fallback notification data');
  }

  // Configure notification options
  const options: any = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    data: notificationData.data,
    actions: [
      { action: 'view', title: 'View', icon: undefined },
      { action: 'dismiss', title: 'Dismiss', icon: undefined }
    ],
    tag: 'otms-notification', // Groups notifications with same tag
    requireInteraction: false, // Auto-dismiss after timeout
    vibrate: [200, 100, 200], // Vibration pattern for mobile devices
    renotify: false // Don't re-alert user if notification with same tag exists
  };

  // Display notification
  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
      .then(() => {
        console.log('[SW] Notification displayed successfully');
      })
      .catch((error) => {
        console.error('[SW] Error displaying notification:', error);
      })
  );
});

/**
 * Validates and sanitizes target URL for navigation
 *
 * Ensures URL is safe for navigation and belongs to same origin.
 * Handles both relative and absolute URLs.
 *
 * @param url - Target URL from notification data
 * @returns Validated URL string or default fallback
 */
function validateAndSanitizeUrl(url: string | undefined): string {
  // Default fallback
  const defaultUrl = '/';

  if (!url || typeof url !== 'string') {
    console.warn('[SW] Invalid URL provided, using default:', defaultUrl);
    return defaultUrl;
  }

  try {
    // Handle relative URLs
    if (url.startsWith('/')) {
      // Relative URL is safe, just ensure no double slashes
      return url.replace(/\/+/g, '/');
    }

    // Handle absolute URLs - must be same origin
    const targetUrl = new URL(url, self.location.origin);

    if (targetUrl.origin !== self.location.origin) {
      console.warn('[SW] External URL blocked for security:', url);
      return defaultUrl;
    }

    // Return pathname + search + hash to ensure same-origin navigation
    return targetUrl.pathname + targetUrl.search + targetUrl.hash;
  } catch (error) {
    console.error('[SW] Error parsing URL:', error);
    return defaultUrl;
  }
}

/**
 * Intelligent PWA Notification Click Handler
 *
 * Handles notification clicks with PWA-first routing:
 * 1. Prioritizes existing PWA windows over opening new ones
 * 2. Uses client.navigate() when available, postMessage fallback
 * 3. Validates URLs to prevent navigation to external/malicious sites
 * 4. Implements browser compatibility fallbacks
 *
 * Notification Click Event Listener (INACTIVE INFRASTRUCTURE)
 * Currently inactive in MVP - infrastructure only.
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('[SW] Notification clicked:', {
    action: event.action,
    hasData: !!event.notification.data
  });

  // Close the notification (AC: 7)
  event.notification.close();

  // Handle 'dismiss' action - just close, no further action
  if (event.action === 'dismiss') {
    console.log('[SW] Notification dismissed by user');
    return;
  }

  // Handle 'view' action or notification body click
  // Extract and validate target URL from notification data (AC: 5)
  const rawUrl = event.notification.data?.targetUrl || '/';
  const targetUrl = validateAndSanitizeUrl(rawUrl);

  console.log('[SW] Opening PWA to:', targetUrl);

  // Handle notification click with intelligent PWA routing
  event.waitUntil(
    handleNotificationClick(targetUrl)
      .catch((error) => {
        console.error('[SW] Error handling notification click:', error);
        // Ultimate fallback - try to open window anyway
        if (clients.openWindow) {
          return clients.openWindow(targetUrl);
        }
      })
  );
});

/**
 * Handles notification click with intelligent PWA window management
 *
 * Strategy:
 * 1. Check for existing PWA windows (AC: 2)
 * 2. If found: Focus and navigate existing window (AC: 3)
 * 3. If not found: Open new PWA window (AC: 4)
 * 4. Use navigate() API when available, postMessage fallback (AC: 8)
 *
 * @param targetUrl - Validated URL to navigate to
 */
async function handleNotificationClick(targetUrl: string): Promise<WindowClient | void> {
  // Feature detection for Clients API (AC: 8)
  if (!('clients' in self)) {
    console.warn('[SW] Clients API not available, using fallback');
    // Fallback for very old browsers
    if ('openWindow' in clients) {
      return clients.openWindow(targetUrl);
    }
    return;
  }

  try {
    // Find all window clients (AC: 2)
    const clientList = await clients.matchAll({
      type: 'window',
      includeUncontrolled: true
    });

    console.log('[SW] Found client windows:', clientList.length);

    // Filter for PWA windows (same origin) (AC: 6)
    const pwaClients = clientList.filter(client => {
      try {
        const clientUrl = new URL(client.url);
        return clientUrl.origin === self.location.origin;
      } catch {
        return false;
      }
    });

    console.log('[SW] PWA windows found:', pwaClients.length);

    // If PWA window exists: Focus and navigate (AC: 3)
    if (pwaClients.length > 0) {
      const client = pwaClients[0];

      console.log('[SW] Focusing existing PWA window');

      // Focus the window first
      const focusedClient = await client.focus();

      // Navigate using client.navigate() if available (modern browsers)
      if ('navigate' in focusedClient && typeof focusedClient.navigate === 'function') {
        console.log('[SW] Navigating using client.navigate()');
        return focusedClient.navigate(targetUrl);
      } else {
        // Fallback: Use postMessage for older browsers (Safari) (AC: 8)
        console.log('[SW] Using postMessage fallback for navigation');
        focusedClient.postMessage({
          type: 'NAVIGATE_TO',
          url: targetUrl
        });
        return focusedClient;
      }
    }

    // No PWA window exists: Open new window (AC: 4)
    if ('openWindow' in clients && typeof clients.openWindow === 'function') {
      console.log('[SW] Opening new PWA window');
      const newClient = await clients.openWindow(targetUrl);

      if (newClient) {
        return newClient;
      } else {
        console.warn('[SW] Failed to open new window (may be blocked by browser)');
      }
    } else {
      // Very old browser without openWindow support (AC: 8)
      console.warn('[SW] clients.openWindow not supported');
    }
  } catch (error) {
    console.error('[SW] Error in handleNotificationClick:', error);
    throw error; // Re-throw to be caught by outer handler
  }
}

/**
 * Service Worker Activation Event
 *
 * Ensures service worker takes control immediately after activation.
 */
self.addEventListener('activate', (event) => {
  console.log('[SW] Service worker activated');
  event.waitUntil(self.clients.claim());
});

/**
 * Service Worker Installation Event
 *
 * Logged for debugging purposes.
 */
self.addEventListener('install', (event) => {
  console.log('[SW] Service worker installed');
  // Skip waiting to activate immediately
  self.skipWaiting();
});

// ============================================================================
// END PUSH NOTIFICATION INFRASTRUCTURE
// ============================================================================
