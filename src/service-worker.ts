/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';

declare const self: ServiceWorkerGlobalScope;
declare const clients: Clients;

// Precache and route assets generated by Vite PWA plugin
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches from previous versions
cleanupOutdatedCaches();

// ============================================================================
// PUSH NOTIFICATION INFRASTRUCTURE (INACTIVE - MVP)
// ============================================================================
// This infrastructure is in place for future activation of push notifications.
// In the current MVP, no actual push notifications are sent from the backend.
// Handlers are tested and ready for activation in future releases.
// ============================================================================

/**
 * Push Event Listener (INACTIVE INFRASTRUCTURE)
 *
 * Handles incoming push notifications from the backend.
 * Currently inactive in MVP - infrastructure only.
 *
 * Expected payload structure:
 * {
 *   title: string,       // Notification title
 *   body: string,        // Notification message
 *   icon?: string,       // Icon URL (defaults to app icon)
 *   badge?: string,      // Badge icon URL (optional)
 *   data?: {            // Custom data for routing
 *     url: string,       // Target route when notification clicked
 *     type?: string,     // Notification type (e.g., 'ot_approved')
 *     ...               // Additional custom fields
 *   }
 * }
 */
self.addEventListener('push', (event: PushEvent) => {
  console.log('[SW] Push event received (infrastructure only, not active in MVP)');

  // Default notification data with fallback values
  let notificationData = {
    title: 'OTMS Notification',
    body: 'You have a new update',
    icon: '/icons/icon-512x512.png',
    badge: '/icons/icon-192x192.png', // Using 192x192 as badge since no dedicated badge icon
    data: { url: '/' }
  };

  try {
    // Parse incoming push payload
    if (event.data) {
      const payload = event.data.json();

      // Merge payload with defaults, preserving fallbacks for missing fields
      notificationData = {
        title: payload.title || notificationData.title,
        body: payload.body || notificationData.body,
        icon: payload.icon || notificationData.icon,
        badge: payload.badge || notificationData.badge,
        data: payload.data || notificationData.data
      };

      console.log('[SW] Push payload parsed:', {
        title: notificationData.title,
        hasData: !!notificationData.data
      });
    }
  } catch (error) {
    console.error('[SW] Error parsing push payload:', error);
    // Continue with fallback notification data
    console.log('[SW] Using fallback notification data');
  }

  // Configure notification options
  const options: NotificationOptions = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    data: notificationData.data,
    actions: [
      { action: 'view', title: 'View', icon: undefined },
      { action: 'dismiss', title: 'Dismiss', icon: undefined }
    ],
    tag: 'otms-notification', // Groups notifications with same tag
    requireInteraction: false, // Auto-dismiss after timeout
    vibrate: [200, 100, 200], // Vibration pattern for mobile devices
    renotify: false // Don't re-alert user if notification with same tag exists
  };

  // Display notification
  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
      .then(() => {
        console.log('[SW] Notification displayed successfully');
      })
      .catch((error) => {
        console.error('[SW] Error displaying notification:', error);
      })
  );
});

/**
 * Notification Click Event Listener (INACTIVE INFRASTRUCTURE)
 *
 * Handles user interactions with displayed notifications.
 * Routes user to appropriate page based on notification data.
 * Currently inactive in MVP - infrastructure only.
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('[SW] Notification clicked:', {
    action: event.action,
    hasData: !!event.notification.data
  });

  // Close the notification
  event.notification.close();

  // Handle 'dismiss' action - just close, no further action
  if (event.action === 'dismiss') {
    console.log('[SW] Notification dismissed by user');
    return;
  }

  // Handle 'view' action or notification body click
  // Extract target URL from notification data
  const urlToOpen = event.notification.data?.url || '/';

  console.log('[SW] Opening app to:', urlToOpen);

  // Open or focus app window
  event.waitUntil(
    clients.matchAll({
      type: 'window',
      includeUncontrolled: true
    })
      .then((clientList) => {
        // Check if there's already a window open with the target URL
        for (const client of clientList) {
          if (client.url.includes(urlToOpen) && 'focus' in client) {
            console.log('[SW] Focusing existing window');
            return client.focus();
          }
        }

        // Check if there's any window open to the app
        for (const client of clientList) {
          if (client.url.includes(self.location.origin) && 'focus' in client) {
            console.log('[SW] Focusing existing app window and navigating');
            return client.focus().then(() => {
              // Navigate to target URL (client-side routing will handle)
              return client.navigate(urlToOpen);
            });
          }
        }

        // No existing window found, open new one
        if (clients.openWindow) {
          console.log('[SW] Opening new window');
          return clients.openWindow(urlToOpen);
        }
      })
      .catch((error) => {
        console.error('[SW] Error handling notification click:', error);
      })
  );
});

/**
 * Service Worker Activation Event
 *
 * Ensures service worker takes control immediately after activation.
 */
self.addEventListener('activate', (event) => {
  console.log('[SW] Service worker activated');
  event.waitUntil(self.clients.claim());
});

/**
 * Service Worker Installation Event
 *
 * Logged for debugging purposes.
 */
self.addEventListener('install', (event) => {
  console.log('[SW] Service worker installed');
  // Skip waiting to activate immediately
  self.skipWaiting();
});

// ============================================================================
// END PUSH NOTIFICATION INFRASTRUCTURE
// ============================================================================
